<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Local Multiplayer Shooter</title>
    <style>
        body { margin: 0; padding: 0; background-color: #000; color: #fff; font-family: Arial, sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; overflow: hidden; }
        #gameCanvas { background-color: #111; border: 2px solid #fff; touch-action: none; }
        #controls, #connection { margin-top: 10px; text-align: center; }
        textarea { width: 90%; height: 60px; margin: 5px 0; }
        button { padding: 10px 15px; font-size: 16px; cursor: pointer; }
        #shootBtn { position: fixed; bottom: 20px; right: 20px; width: 80px; height: 80px; border-radius: 50%; background-color: red; color: white; font-size: 18px; border: 2px solid white; }
    </style>
</head>
<body>

    <div id="connection">
        <h3>WebRTC P2P Connection</h3>
        <button onclick="createOffer()">Create Game</button>
        <textarea id="offer" placeholder="Offer code will appear here..."></textarea>
        <button onclick="joinGame()">Join Game</button>
        <textarea id="answer" placeholder="Paste Offer here to create Answer, or paste Answer from peer here..."></textarea>
        <button onclick="confirmConnection()">Confirm Connection</button>
        <p id="status">Status: Disconnected</p>
    </div>

    <canvas id="gameCanvas" style="display:none;"></canvas>
    <button id="shootBtn" style="display:none;">Shoot</button>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const shootBtn = document.getElementById('shootBtn');
        const connectionDiv = document.getElementById('connection');
        const statusEl = document.getElementById('status');
        
        canvas.width = window.innerWidth * 0.95;
        canvas.height = window.innerHeight * 0.7;

        let peerConnection;
        let dataChannel;

        const player1 = { x: 50, y: canvas.height / 2, width: 30, height: 30, color: 'cyan', bullets: [], health: 100 };
        const player2 = { x: canvas.width - 80, y: canvas.height / 2, width: 30, height: 30, color: 'magenta', bullets: [], health: 100 };
        let thisPlayer = null;
        let otherPlayer = null;
        let isHost = false;

        function setupPeerConnection() {
            try {
                peerConnection = new RTCPeerConnection({
                    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                });

                peerConnection.onicecandidate = event => {
                    if (!event.candidate) {
                        // When ICE gathering is complete, the description is fully formed.
                        // We update the text area again to ensure it has all candidates.
                        if (peerConnection.localDescription) {
                            const descriptionText = JSON.stringify(peerConnection.localDescription);
                            if (isHost) {
                                document.getElementById('offer').value = descriptionText;
                            } else {
                                document.getElementById('answer').value = descriptionText;
                            }
                        }
                    }
                };

                peerConnection.ondatachannel = event => {
                    dataChannel = event.channel;
                    setupDataChannel();
                };
            } catch (e) {
                statusEl.innerText = "Error: WebRTC not supported or blocked in this browser.";
                console.error("RTCPeerConnection error: ", e);
            }
        }

        function setupDataChannel() {
            dataChannel.onopen = () => {
                statusEl.innerText = "Status: Connected!";
                connectionDiv.style.display = 'none';
                canvas.style.display = 'block';
                shootBtn.style.display = 'block';
                gameLoop();
            };

            dataChannel.onmessage = event => {
                const data = JSON.parse(event.data);
                if (data.type === 'pos') {
                    otherPlayer.x = data.x;
                    otherPlayer.y = data.y;
                }
                if (data.type === 'bullet') {
                    otherPlayer.bullets.push({ x: data.x, y: data.y, width: 5, height: 5 });
                }
                if (data.type === 'hit') {
                    thisPlayer.health -= 10;
                }
            };
        }
        
        async function createOffer() {
            isHost = true;
            thisPlayer = player1;
            otherPlayer = player2;
            setupPeerConnection();
            if (!peerConnection) return;
            
            dataChannel = peerConnection.createDataChannel('game');
            setupDataChannel();
            
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);

            // *** IMPORTANT CHANGE HERE ***
            // Show the offer immediately without waiting for all ICE candidates
            document.getElementById('offer').value = JSON.stringify(peerConnection.localDescription);
            statusEl.innerText = "Offer created. Copy it and send to the other player.";
        }

        async function joinGame() {
            if (!isHost) {
                thisPlayer = player2;
                otherPlayer = player1;
            }
            setupPeerConnection();
            if (!peerConnection) return;

            const offerText = document.getElementById('answer').value;
            if (!offerText.trim()) {
                statusEl.innerText = "Please paste the Offer code first.";
                return;
            }

            const offer = JSON.parse(offerText);
            await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            
            // *** IMPORTANT CHANGE HERE ***
            // Show the answer immediately
            document.getElementById('answer').value = JSON.stringify(peerConnection.localDescription);
            statusEl.innerText = "Answer created. Copy it and send back to the host.";
        }
        
        async function confirmConnection() {
            const answerText = document.getElementById('answer').value;
             if (!answerText.trim() || !peerConnection) {
                statusEl.innerText = "Please create an offer and paste the answer first.";
                return;
            }
            const answer = JSON.parse(answerText);
            if (peerConnection.signalingState !== 'have-local-offer') {
                statusEl.innerText = "Connection Error: Invalid state for setting remote answer.";
                return;
            }
            await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
        }

        // --- The rest of the game logic (drawing, update, controls) remains the same ---
        function drawPlayer(player) {
            ctx.fillStyle = player.color;
            ctx.fillRect(player.x, player.y, player.width, player.height);
            ctx.fillStyle = 'red';
            ctx.fillRect(player.x, player.y - 10, player.width, 5);
            ctx.fillStyle = 'green';
            ctx.fillRect(player.x, player.y - 10, player.width * (player.health / 100), 5);
        }

        function drawBullet(bullet, color) { ctx.fillStyle = color; ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height); }
        
        function update() {
            thisPlayer.bullets.forEach((bullet, index) => {
                bullet.x += isHost ? 5 : -5;
                if (bullet.x > canvas.width || bullet.x < 0) thisPlayer.bullets.splice(index, 1);
                if (bullet.x < otherPlayer.x + otherPlayer.width && bullet.x + bullet.width > otherPlayer.x && bullet.y < otherPlayer.y + otherPlayer.height && bullet.y + bullet.height > otherPlayer.y) {
                    thisPlayer.bullets.splice(index, 1);
                    dataChannel.send(JSON.stringify({ type: 'hit' }));
                }
            });
            otherPlayer.bullets.forEach((bullet, index) => { bullet.x += isHost ? -5 : 5; if (bullet.x > canvas.width || bullet.x < 0) otherPlayer.bullets.splice(index, 1); });
            if (player1.health <= 0 || player2.health <= 0) { alert(`Game Over! ${player1.health <= 0 ? 'Player 2' : 'Player 1'} wins!`); document.location.reload(); }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawPlayer(player1);
            drawPlayer(player2);
            player1.bullets.forEach(b => drawBullet(b, player1.color));
            player2.bullets.forEach(b => drawBullet(b, player2.color));
        }
        
        function gameLoop() { requestAnimationFrame(gameLoop); update(); draw(); }
        
        function sendPosition() { if (dataChannel && dataChannel.readyState === 'open') { dataChannel.send(JSON.stringify({ type: 'pos', x: thisPlayer.x, y: thisPlayer.y })); } }

        canvas.addEventListener('touchmove', (e) => { e.preventDefault(); const touch = e.touches[0]; const rect = canvas.getBoundingClientRect(); thisPlayer.x = touch.clientX - rect.left - thisPlayer.width / 2; thisPlayer.y = touch.clientY - rect.top - thisPlayer.height / 2; sendPosition(); });
        shootBtn.addEventListener('click', () => { const bullet = { x: thisPlayer.x + (isHost ? thisPlayer.width : -5), y: thisPlayer.y + thisPlayer.height / 2 - 2.5, width: 5, height: 5, }; thisPlayer.bullets.push(bullet); if (dataChannel && dataChannel.readyState === 'open') { dataChannel.send(JSON.stringify({ type: 'bullet', x: bullet.x, y: bullet.y })); } });
    </script>
</body>
</html>
