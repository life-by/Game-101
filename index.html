<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Advanced P2P Shooter</title>
    <style>
        body { margin: 0; padding: 0; background-color: #0c0c0c; color: #fff; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; overflow: hidden; }
        .container { text-align: center; padding: 20px; }
        input, button { padding: 12px 18px; font-size: 16px; border-radius: 8px; border: 1px solid #555; margin: 5px; }
        input { background-color: #333; color: #fff; text-align: center; letter-spacing: 2px; }
        button { cursor: pointer; background-color: #007BFF; color: white; border: none; }
        #gameCodeDisplay { font-size: 24px; font-weight: bold; letter-spacing: 4px; color: #28a745; margin: 15px 0; }
        #status { color: #ffc107; }
        #gameContainer { position: relative; }
        #gameCanvas { background-color: #1a1a1a; border-radius: 10px; }
        #shootBtn { position: fixed; bottom: 20px; right: 20px; width: 80px; height: 80px; border-radius: 50%; background-color: #dc3545; color: white; font-size: 18px; border: 2px solid white; z-index: 100; }
        #gameOverScreen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.8); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 200; }
        #gameOverScreen h2 { font-size: 48px; color: #dc3545; }
        #connection, #gameContainer { display: block; }
        .hidden { display: none !important; }
    </style>
</head>
<body>

    <div id="connection" class="container">
        <h3>Advanced P2P Shooter</h3>
        <button onclick="createGame()">Create Game</button>
        <div id="gameCodeDisplay"></div>
        <hr style="width:80%; margin: 20px auto; border-color: #444;">
        <input type="text" id="joinCodeInput" placeholder="Enter 6-Digit Code">
        <button onclick="joinGame()">Join Game</button>
        <p id="status">Status: Disconnected</p>
    </div>

    <div id="gameContainer" class="hidden">
        <canvas id="gameCanvas"></canvas>
        <div id="gameOverScreen">
            <h2 id="winnerText"></h2>
            <button onclick="playAgain()">Play Again</button>
        </div>
    </div>
    <button id="shootBtn" class="hidden">Shoot</button>

    <!-- Sound Effects -->
    <audio id="shootSound" src="https://www.soundjay.com/buttons/sounds/button-16.mp3" preload="auto"></audio>
    <audio id="hitSound" src="https://www.soundjay.com/mechanical/sounds/explosion-01.mp3" preload="auto"></audio>

    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/8.6.8/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.6.8/firebase-database.js"></script>

    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyCBukPCFS4aNvyNnNChBbhl-287a0Or3JY",
            authDomain: "tangim-28d01.firebaseapp.com",
            databaseURL: "https://tangim-28d01-default-rtdb.firebaseio.com",
            projectId: "tangim-28d01",
            storageBucket: "tangim-28d01.appspot.com",
            messagingSenderId: "787567404249",
            appId: "1:787567404249:web:630c0df0f642baaaa50ac8"
        };
        if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
        const db = firebase.database();

        // DOM Elements
        const elements = {
            connectionDiv: document.getElementById('connection'),
            gameContainer: document.getElementById('gameContainer'),
            canvas: document.getElementById('gameCanvas'),
            shootBtn: document.getElementById('shootBtn'),
            statusEl: document.getElementById('status'),
            gameCodeDisplay: document.getElementById('gameCodeDisplay'),
            gameOverScreen: document.getElementById('gameOverScreen'),
            winnerText: document.getElementById('winnerText'),
            shootSound: document.getElementById('shootSound'),
            hitSound: document.getElementById('hitSound')
        };
        const ctx = elements.canvas.getContext('2d');
        
        // Game State
        let peerConnection, dataChannel, gameCode, thisPlayer, otherPlayer;
        let isHost = false;
        let obstacles = [];
        let animationFrameId;
        
        const gameState = {
            player1: { x: 50, y: 0, width: 40, height: 40, sprite: 'ðŸš€', bullets: [], health: 100, score: 0 },
            player2: { x: 0, y: 0, width: 40, height: 40, sprite: 'ðŸ‘¾', bullets: [], health: 100, score: 0 },
            isOver: false
        };

        function initGameLayout() {
            elements.canvas.width = window.innerWidth * 0.95;
            elements.canvas.height = window.innerHeight * 0.8;
            gameState.player1.y = elements.canvas.height / 2;
            gameState.player2.x = elements.canvas.width - 80;
            gameState.player2.y = elements.canvas.height / 2;
        }
        initGameLayout();

        function resetGame() {
            gameState.player1.health = 100;
            gameState.player2.health = 100;
            gameState.player1.score = 0;
            gameState.player2.score = 0;
            gameState.player1.bullets = [];
            gameState.player2.bullets = [];
            gameState.isOver = false;
            elements.gameOverScreen.style.display = 'none';
            initGameLayout();

            if(isHost) {
                generateObstacles();
                sendData({ type: 'obstacles', obstacles: obstacles });
            }
            gameLoop();
        }

        function playAgain() {
            sendData({ type: 'play_again' });
            resetGame();
        }

        function generateObstacles() {
            obstacles = [];
            for (let i = 0; i < 5; i++) {
                obstacles.push({
                    x: Math.random() * (elements.canvas.width - 200) + 100,
                    y: Math.random() * (elements.canvas.height - 100) + 50,
                    width: Math.random() * 50 + 20,
                    height: Math.random() * 50 + 20,
                });
            }
        }
        
        const servers = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

        async function createGame() {
            isHost = true;
            thisPlayer = gameState.player1;
            otherPlayer = gameState.player2;
            gameCode = Math.floor(100000 + Math.random() * 900000).toString();
            elements.gameCodeDisplay.innerText = `Your Code: ${gameCode}`;
            elements.statusEl.innerText = "Creating game... Share the code!";

            peerConnection = new RTCPeerConnection(servers);
            dataChannel = peerConnection.createDataChannel('game');
            setupDataChannelEvents();
            
            const gameRef = db.ref(`games/${gameCode}`);
            await gameRef.set({ offer: null, answer: null, hostCandidates: [], clientCandidates: [] });
            
            peerConnection.onicecandidate = e => e.candidate && gameRef.child('hostCandidates').push(e.candidate.toJSON());
            
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            await gameRef.child('offer').set({ sdp: offer.sdp, type: offer.type });

            gameRef.child('answer').on('value', snapshot => {
                if (snapshot.exists() && !peerConnection.currentRemoteDescription) {
                    peerConnection.setRemoteDescription(new RTCSessionDescription(snapshot.val()));
                }
            });
            gameRef.child('clientCandidates').on('child_added', s => peerConnection.addIceCandidate(new RTCIceCandidate(s.val())));
        }

        async function joinGame() {
            isHost = false;
            thisPlayer = gameState.player2;
            otherPlayer = gameState.player1;
            gameCode = document.getElementById('joinCodeInput').value;
            if (!gameCode || gameCode.length !== 6) { elements.statusEl.innerText = "Please enter a valid 6-digit code."; return; }
            elements.statusEl.innerText = `Joining game ${gameCode}...`;

            const gameRef = db.ref(`games/${gameCode}`);
            const offerSnapshot = await gameRef.child('offer').get();
            if (!offerSnapshot.exists()) { elements.statusEl.innerText = "Game code not found."; return; }

            peerConnection = new RTCPeerConnection(servers);
            peerConnection.ondatachannel = e => { dataChannel = e.channel; setupDataChannelEvents(); };
            peerConnection.onicecandidate = e => e.candidate && gameRef.child('clientCandidates').push(e.candidate.toJSON());
            
            await peerConnection.setRemoteDescription(new RTCSessionDescription(offerSnapshot.val()));
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            await gameRef.child('answer').set({ sdp: answer.sdp, type: answer.type });

            gameRef.child('hostCandidates').on('child_added', s => peerConnection.addIceCandidate(new RTCIceCandidate(s.val())));
        }

        function setupDataChannelEvents() {
            dataChannel.onopen = () => {
                elements.connectionDiv.classList.add('hidden');
                elements.gameContainer.classList.remove('hidden');
                elements.shootBtn.classList.remove('hidden');
                db.ref(`games/${gameCode}`).remove();
                if(isHost) {
                   generateObstacles();
                   sendData({ type: 'obstacles', obstacles: obstacles });
                }
                gameLoop();
            };

            dataChannel.onmessage = event => {
                const data = JSON.parse(event.data);
                if (data.type === 'pos') { otherPlayer.x = data.x; otherPlayer.y = data.y; }
                if (data.type === 'bullet') { otherPlayer.bullets.push({ x: data.x, y: data.y, width: 10, height: 10 }); }
                if (data.type === 'hit') { thisPlayer.health -= 10; otherPlayer.score += 1; elements.hitSound.play(); }
                if (data.type === 'obstacles') { obstacles = data.obstacles; }
                if (data.type === 'play_again') { resetGame(); }
            };
        }

        function sendData(data) {
            if (dataChannel && dataChannel.readyState === 'open') {
                dataChannel.send(JSON.stringify(data));
            }
        }

        function detectCollision(a, b) {
            return a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.y + a.height > b.y;
        }

        function update() {
            if (gameState.isOver) return;
            // Update bullets
            thisPlayer.bullets.forEach((bullet, bIndex) => {
                bullet.x += isHost ? 7 : -7;
                if (bullet.x > elements.canvas.width || bullet.x < 0) { thisPlayer.bullets.splice(bIndex, 1); }
                // Bullet-Player collision
                if (detectCollision(bullet, otherPlayer)) {
                    thisPlayer.bullets.splice(bIndex, 1);
                    thisPlayer.score += 1;
                    sendData({ type: 'hit' });
                    elements.hitSound.play();
                }
                // Bullet-Obstacle collision
                obstacles.forEach(obs => {
                    if(detectCollision(bullet, obs)) { thisPlayer.bullets.splice(bIndex, 1); }
                });
            });
            otherPlayer.bullets.forEach(b => b.x += isHost ? -7 : 7);

            // Check for game over
            if (gameState.player1.health <= 0 || gameState.player2.health <= 0) {
                gameState.isOver = true;
                elements.gameOverScreen.style.display = 'flex';
                elements.winnerText.innerText = gameState.player1.health <= 0 ? "ðŸ‘¾ Alien Wins!" : "ðŸš€ Rocket Wins!";
                cancelAnimationFrame(animationFrameId);
            }
        }

        function draw() {
            ctx.clearRect(0, 0, elements.canvas.width, elements.canvas.height);
            // Draw obstacles
            ctx.fillStyle = '#6c757d';
            obstacles.forEach(obs => ctx.fillRect(obs.x, obs.y, obs.width, obs.height));
            
            // Draw players and bullets
            [gameState.player1, gameState.player2].forEach(p => {
                ctx.font = `${p.width}px Arial`;
                ctx.fillText(p.sprite, p.x, p.y + p.height - 10);
                p.bullets.forEach(b => { ctx.fillStyle = 'orange'; ctx.fillRect(b.x, b.y, b.width, b.height); });
            });
            
            // Draw UI (Health & Score)
            ctx.font = '16px Segoe UI';
            // Player 1 UI
            ctx.fillStyle = 'cyan';
            ctx.fillText(`P1 Score: ${gameState.player1.score}`, 10, 20);
            ctx.fillStyle = 'red';
            ctx.fillRect(10, 30, 100, 10);
            ctx.fillStyle = 'lime';
            ctx.fillRect(10, 30, gameState.player1.health, 10);
            // Player 2 UI
            const p2ScoreText = `P2 Score: ${gameState.player2.score}`;
            const textWidth = ctx.measureText(p2ScoreText).width;
            ctx.fillStyle = 'magenta';
            ctx.fillText(p2ScoreText, elements.canvas.width - textWidth - 10, 20);
            ctx.fillStyle = 'red';
            ctx.fillRect(elements.canvas.width - 110, 30, 100, 10);
            ctx.fillStyle = 'lime';
            ctx.fillRect(elements.canvas.width - 110, 30, gameState.player2.health, 10);
        }
        
        function gameLoop() {
            update();
            draw();
            animationFrameId = requestAnimationFrame(gameLoop);
        }
        
        // Event Listeners
        elements.canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = elements.canvas.getBoundingClientRect();
            let newX = touch.clientX - rect.left - thisPlayer.width / 2;
            let newY = touch.clientY - rect.top - thisPlayer.height / 2;

            // Collision check with canvas boundaries
            if (newX < 0) newX = 0;
            if (newX + thisPlayer.width > elements.canvas.width) newX = elements.canvas.width - thisPlayer.width;
            if (newY < 0) newY = 0;
            if (newY + thisPlayer.height > elements.canvas.height) newY = elements.canvas.height - thisPlayer.height;
            
            thisPlayer.x = newX;
            thisPlayer.y = newY;
            sendData({ type: 'pos', x: thisPlayer.x, y: thisPlayer.y });
        });
        
        elements.shootBtn.addEventListener('click', () => {
            if(gameState.isOver) return;
            const bullet = {
                x: thisPlayer.x + (isHost ? thisPlayer.width : -10),
                y: thisPlayer.y + thisPlayer.height / 2 - 5,
                width: 10,
                height: 10,
            };
            thisPlayer.bullets.push(bullet);
            sendData({ type: 'bullet', x: bullet.x, y: bullet.y });
            elements.shootSound.play();
        });
    </script>
</body>
</html>
